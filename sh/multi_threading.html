<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Многопоточность</title>
    <link rel="stylesheet" href="./css/main.css">
</head>
<body>
    <h1>Volatile</h1>
    Гарантирует что каждый поток работает непосредственно с этой переменной. Не с кешем.<br>
    если обращение к переменной ВСЕГДА происходит их Synchronized блоков - Volatile не нужен<br>
    <br>

    <h1>Атомарные типы данных</h1>
    CAS (Compare-And-Swap). java.util.concurrent.atomic<br>
    <div class="tab">
        <b>AtomicInteger:</b> get, set, incrementAndGet (атомарно увеличивает на 1), decrementAndGet (атомарно уменьшает на 1), addAndGet и compareAndSet.<br>
        <b>AtomicLong:</b> то же самое с long.<br>
        <b>AtomicBoolean</b><br>
        <b>AtomicReference:</b> с ссылочными типами данных: get, set и compareAndSet для объектов.<br>
        <b>AtomicIntegerArray, AtomicLongArray, AtomicReferenceArray</b><br>
    </div>
    <br>

    <h1>Дедлок</h1>
    Бывает когда потоки взаимно ждут друг друга<br>
    <div class="tab">
        <b>1. Взаимный JOIN:</b><br>
        <div class="tab">
            в первом потоке thread2.join();<br>
            а во втором thread1.join();<br>
        </div>
        <b>2. Взаимное ожидание ресурсов:</b><br>
        <div class="tab">
            Поток A захватывает ресурс R1 и ожидает ресурс R2.<br>
            Поток B захватывает ресурс R2 и ожидает ресурс R1.<br>
        </div>
    </div>
    <br>

    <h1>Создание пула в соответствии с количеством ядер</h1>
    <pre>
        int cores = Runtime.getRuntime().availableProcessors();
        ExecutorService executor = Executors.newFixedThreadPool(cores);
        executor.submit(new CallableImpl());</pre>
</body>
</html>