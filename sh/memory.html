<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Память и GC</title>
</head>
<body>
    <b><u>Устройство памяти</u></b><br>
    <b>1. Куча (Heap):</b> Тут содержаться все объекты классов.<br>
    &nbsp&nbsp&nbsp&nbsp <b>Young Generation</b><br>
    &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp <b>Eden Space</b> Тут создаются новые объекты.<br>
    &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp <b>Survivor Spaces (S0 and S1)</b> Перемещаются сюда после минорного сбора мусора.<br>
    &nbsp&nbsp&nbsp&nbsp <b>Old Generation (Tenured Generation):</b> Объекты, которые долго существуют, перемещаются сюда.<br>
    &nbsp&nbsp&nbsp&nbsp <b>Permanent Generation / Metaspace (в Java 8 и выше):</b> Хранит метаданные классов и строковый пул. Использует нативную память.<br>
    <b>2. Стек (Stack):</b> Каждый поток имеет свой собственный стек, который содержит информацию о вызовах методов и локальных переменных. Каждый новый вызов метода создает новый блок в стеке <b>(stack frame)</b>.<br>
    <b>3. Code:</b> Область памяти, где хранится скомпилированный код.<br>
    <b>4. Static (Permanent):</b> Хранит статические члены класса.<br>
    <br>
    <b><u>GC корни</u></b><br>
    1. Локальные переменные и параметры активных методов (методов в стеке вызовов)<br>
    2. Активные потоки<br>
    3. Статические поля классов<br>
    4. Системные классы и загрузчики классов<br>
    5. JNI (Java Native Interface) ссылки<br>
    <br>
    <b><u>Виды ссылок</u></b><br>
    <b>Strong Reference</b> Обычный тип ссылки, Обьект не будет собран GC.<br>
    <b>Soft Reference</b> java.lang.ref.SoftReference. Будет собран GC только в случае нехватки памяти.<br>
    Полезны для реализации кешей, где вы не против его удаления в условиях нехватки памяти.<br>
    <b>Weak Reference</b> java.lang.ref.WeakReference. Будет собран GC если нет других ссылок.<br>
    Применяется в String pool и т.п.<br>
    <b>Phantom Reference</b> java.lang.ref.PhantomReference.<br>
    После удаления сборщиком мусора попадает в ReferenceQueue<br>
    <br>
    <b><u>Как найти утечку памяти</u></b><br>
    <b>1. Профилирование приложения:</b> Профайлеры наблюдают за использованием памяти. Какие объекты занимают и не освобождат память. VisualVM, JProfiler, YourKit или Java Mission Control.<br>
    <b>2. Анализ Heap Dump:</b> jmap делает дамп. Или по OutOfMemoryError (используя JVM опцию -XX:+HeapDumpOnOutOfMemoryError).  Анализируйте с помощью Eclipse Memory Analyzer (MAT).<br>
    <b>3. Проверка кода:</b><br>
    Статические коллекции.
    Наблюдатели и слушатели событий, которые не удаляются.
    Кэширование без стратегии изгнания.
    Неправильное использование ThreadLocal.
    Большие статические объекты.
    GC логи:
    Включите логирование сборщика мусора с помощью JVM параметров -XX:+PrintGCDetails и -XX:+PrintGCDateStamps, а затем проанализируйте логи на предмет частых полных сборок мусора (Full GC), которые не освобождают достаточно памяти.

    Проверка на утечки памяти в сторонних библиотеках:
    Убедитесь, что используемые вами библиотеки не имеют известных утечек памяти. Поищите соответствующие проблемы и обновления для этих библиотек.

    Unit Testing:
    Используйте unit тесты с инструментами, такими как JUnit и наборы для тестирования утечки памяти, например, JMemoryBuddy.

    Code Reviews:
    Регулярные ревью кода могут помочь обнаружить потенциальные утечки памяти на ранних стадиях разработки.

    Инструменты статического анализа:
    Используйте инструменты статического анализа, такие как FindBugs или PMD, которые могут выявлять образцы кода, потенциально приводящие к утечкам памяти.

    Стресс-тестирование:
    Проведение стресс-тестирования приложения может выявить утечки памяти, которые проявляются только при определенной нагрузке или после длительного времени работы.


    задать сколько вм будет использовать памяти
</body>
</html>