<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Память и GC</title>
    <link rel="stylesheet" href="./css/main.css">
</head>
<body>
    <h1>Устройство памяти</h1>
    <b>1. Куча (Heap):</b> Тут содержаться все объекты классов.<br>
    <div class="tab">
        <b>Young Generation</b><br>
        <div class="tab">
            <b>Eden Space</b> Тут создаются новые объекты.<br>
            <b>Survivor Spaces (S0 and S1)</b> Перемещаются сюда после минорного сбора мусора.<br>
        </div>
        <b>Old Generation (Tenured Generation):</b> Объекты, которые долго существуют, перемещаются сюда.<br>
        <b>Permanent Generation / Metaspace (в Java 8 и выше):</b> Хранит метаданные классов и строковый пул. Использует нативную память.<br>
    </div>
    <b>2. Стек (Stack):</b> Каждый поток имеет свой собственный стек, который содержит информацию о вызовах методов и локальных переменных. Каждый новый вызов метода создает новый блок в стеке <b>(stack frame)</b>.<br>
    <b>3. Code:</b> Область памяти, где хранится скомпилированный код.<br>
    <b>4. Static (Permanent):</b> Хранит статические члены класса.<br>
    <br>
    <h1>GC корни</h1>
    <div class="tab">
        1. Локальные переменные и параметры активных методов (методов в стеке вызовов)<br>
        2. Активные потоки<br>
        3. Статические поля классов<br>
        4. Системные классы и загрузчики классов<br>
        5. JNI (Java Native Interface) ссылки<br>
    </div>
    <br>
    <h1>Виды ссылок</h1>
    <div class="tab">
        <b>Strong Reference</b> Обычный тип ссылки, Обьект не будет собран GC.<br>
        <b>Soft Reference</b> java.lang.ref.SoftReference. Будет собран GC только в случае нехватки памяти.<br>
        Полезны для реализации кешей, где вы не против его удаления в условиях нехватки памяти.<br>
        <b>Weak Reference</b> java.lang.ref.WeakReference. Будет собран GC если нет других ссылок.<br>
        Применяется в String pool и т.п.<br>
        <b>Phantom Reference</b> java.lang.ref.PhantomReference.<br>
        После удаления сборщиком мусора попадает в ReferenceQueue<br>
    </div>
    <br>
    <h1>Как найти утечку памяти</h1>
    <div class="tab">
        <b>1. Профилирование приложения:</b> Профайлеры наблюдают за использованием памяти. Какие объекты занимают и не освобождат память. VisualVM, JProfiler, YourKit или Java Mission Control.<br>
        <b>2. Анализ Heap Dump:</b> jmap делает дамп. Или по OutOfMemoryError (используя JVM опцию -XX:+HeapDumpOnOutOfMemoryError).  Анализируйте с помощью Eclipse Memory Analyzer (MAT).<br>
        <b>3. Проверка кода:</b><br>
        Статические коллекции.
        Наблюдатели и слушатели событий, которые не удаляются.
        Кэширование без стратегии изгнания.
        Неправильное использование ThreadLocal.
        Большие статические объекты.
        GC логи:
        Включите логирование сборщика мусора с помощью JVM параметров -XX:+PrintGCDetails и -XX:+PrintGCDateStamps, а затем проанализируйте логи на предмет частых полных сборок мусора (Full GC), которые не освобождают достаточно памяти.

        Проверка на утечки памяти в сторонних библиотеках:
        Убедитесь, что используемые вами библиотеки не имеют известных утечек памяти. Поищите соответствующие проблемы и обновления для этих библиотек.

        Unit Testing:
        Используйте unit тесты с инструментами, такими как JUnit и наборы для тестирования утечки памяти, например, JMemoryBuddy.

        Code Reviews:
        Регулярные ревью кода могут помочь обнаружить потенциальные утечки памяти на ранних стадиях разработки.

        Инструменты статического анализа:
        Используйте инструменты статического анализа, такие как FindBugs или PMD, которые могут выявлять образцы кода, потенциально приводящие к утечкам памяти.

        Стресс-тестирование:
        Проведение стресс-тестирования приложения может выявить утечки памяти, которые проявляются только при определенной нагрузке или после длительного времени работы.


        задать сколько вм будет использовать памяти
    </div>
</body>
</html>